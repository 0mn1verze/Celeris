//! # Module: `magic_gen`
//!
//! Handles the generation of "magic bitboards" and associated lookup tables
//! for efficient calculation of sliding piece attacks (bishops and rooks).
//!
//! ## Overview
//!
//! Magic bitboards provide a highly efficient method for determining sliding piece
//! attack patterns by using precomputed tables indexed via a hashing scheme
//! involving carefully chosen "magic" numbers. This avoids expensive iteration
//! or complex calculations during move generation.
//!
//! This module contains the logic to:
//! 1.  **Find Magic Numbers**: Search for suitable 64-bit "magic" numbers for each
//!     square and piece type (bishop/rook). A valid magic number, combined with a
//!     bit shift, maps all relevant occupancy permutations for a square to unique
//!     indices within a compact attack table.
//! 2.  **Populate Attack Tables**: Generate the actual attack bitboards for every
//!     relevant occupancy permutation and store them in the lookup table at the
//!     index determined by the magic number.
//! 3.  **Seed Finding**: Includes functionality (`find_best_magic_seeds`) to help
//!     discover optimal random seeds that lead to faster generation of valid magic
//!     numbers, primarily used during development.
//!
//! ## Key Functions
//!
//! - `gen_slider_attacks`: The main function responsible for generating a complete
//!   `SliderAttackTable` (containing both the attack lookup array and the `Magic`
//!   structs needed for indexing) for a given piece type (Bishop or Rook). This is
//!   typically called once during engine initialization (often via `LazyLock` in `movegen::lookup`).
//! - `find_magics`: The core helper function that performs the search for a valid
//!   magic number for a single square.
//! - `populate_table`: Helper to generate reference attack patterns and occupancy masks.
//! - `find_best_magic_seeds`: A utility function for searching for efficient seeds.
//!
//! ## Usage
//!
//! The primary output, `SliderAttackTable`, is used by the `movegen::lookup` module
//! to provide the `slider_attack` function, enabling fast retrieval of attack sets
//! for sliding pieces based on the current board occupancy.

use crate::core::*;
use crate::movegen::{Magic, SliderAttackTable, attacks_on_the_fly, init_magic_struct};
use crate::utils::PRNG;

const MAX_PERM: usize = 0x1000; // 2^16

/// # Populate reference and occupancy tables
fn populate_table(
    pt: PieceType,
    sq: Square,
    m: &Magic,
    reference: &mut [Bitboard; MAX_PERM],
    occupancy: &mut [Bitboard; MAX_PERM],
) {
    let perm = 1 << m.mask.count_bits();
    // Populate the reference and occupancy tables for the piece type on the square
    let mut occ = Bitboard::EMPTY;
    for i in 0..perm {
        // Generate the corresponding attack rays for the occupancy, piece type, and square
        reference[i] = attacks_on_the_fly(pt, sq, occ);
        // Store the occupancy bitboard at the current index
        occupancy[i] = occ;
        // Save occupancy bitboard at the current index
        occ = (occ - m.mask) & m.mask;
    }
}

/// # Find suitable magic numbers
fn find_magics<const N: usize>(
    seed: u64,
    m: &mut Magic,
    reference: &mut [Bitboard; MAX_PERM],
    occupancy: &mut [Bitboard; MAX_PERM],
    table: &mut [Bitboard; N],
) -> u32 {
    let mut trying = true;
    let mut attempt = 0;
    let mut rng = PRNG::new(seed);
    let mut epoch = [0u32; MAX_PERM];
    let perm = 1 << m.mask.count_bits();
    // Find a magic for a specific mask/square until we find one that passes the
    // verification test
    while trying {
        m.magic = 0;
        // Aim to find a magic number that is sparsely populated
        while ((m.magic.wrapping_mul(m.mask.0)) >> 56).count_ones() < 6 {
            m.magic = rng.random_sparse_u64();
            // New magic number
            attempt += 1;

            // Assume the new magic number is valid, until proven otherwise
            trying = false;
            // A valid magic must map every possible occupancy to an index that
            // looks up the correct sliding atttack in the attacks lookup table.

            for i in 0..perm {
                let idx = m.index(occupancy[i]);
                // Trick to speed up the search for magic numbers
                // The m.attacks table will be slowly replaced with the attacks
                // generated by the new magic number Avoid resetting m.attacks every
                // time
                if epoch[idx - m.offset] < attempt {
                    // Update the count
                    epoch[idx - m.offset] = attempt;
                    // Update the table with the attack pattern
                    table[idx] = reference[i];
                // If the index is already occupied, check if the attack pattern stored is the same as the one we are trying to insert
                } else if table[idx] != reference[i] {
                    // Keep trying new magic numbers until we find one that works
                    trying = true;
                    break;
                }
            }
        }
    }
    attempt
}

/******************************************\
|==========================================|
|              Generate Magic              |
|==========================================|
\******************************************/

/// Seeds for generating magic numbers that optimises for speed
const BISHOP_SEEDS: [u64; Rank::NUM] = [
    0xA4302F8257706E25, // 3444 attempts to generate magic number
    0xF5DFC414DBE20B81, // 1776 attempts to generate magic number
    0x7FA4E09723AAA919, // 7952 attempts to generate magic number
    0xC14C05BE2E3A10BF, // 14684 attempts to generate magic number
    0xC60BA0419F81238E, // 17837 attempts to generate magic number
    0x065AFE010904A1A4, // 10730 attempts to generate magic number
    0x5E040F6D2A6A6FC4, // 2346 attempts to generate magic number
    0xF26CD592A998EBFC, // 2715 attempts to generate magic number
];

const ROOK_SEEDS: [u64; Rank::NUM] = [
    0xA229B9598E24437C, // 474251 attempts to generate magic number
    0x563E0EF1ABAE19AD, // 87109 attempts to generate magic number
    0x81445AC4F7966038, // 153887 attempts to generate magic number
    0xC6D2FB81AC850941, // 111506 attempts to generate magic number
    0x283C0A606438D8B3, // 123736 attempts to generate magic number
    0xEE1D97DF3E4CB9D7, // 131030 attempts to generate magic number
    0xAC18FA699DF5F065, // 75650 attempts to generate magic number
    0x33481A03E05CFBED, // 103092 attempts to generate magic number
];

/// # Generate Magics (~240ms)
/// - Initialize the magic numbers for the rook and bishop pieces.
/// - This is used to generate the attacks for the pieces.
/// - The magic numbers are used to hash the occupancy of the squares to a unique index.
/// - The occupancy is the set of squares that are occupied by pieces.
pub fn gen_slider_attacks<const N: usize>(pt: PieceType) -> SliderAttackTable<N> {
    let mut offset = 0;
    let mut total_attempt = 0;
    let mut reference = [Bitboard::EMPTY; MAX_PERM];
    let mut occupancy = [Bitboard::EMPTY; MAX_PERM];
    let mut table = Box::new([Bitboard::EMPTY; N]);
    let mut magic = [Magic::default(); Square::NUM];

    let seeds = match pt {
        PieceType::Bishop => BISHOP_SEEDS,
        PieceType::Rook => ROOK_SEEDS,
        _ => unreachable!(),
    };

    // Loop through the squares and generate the magic numbers for the piece type
    for sq in Square::iter() {
        // Initialize the magic struct for the piece type on the square
        let mut m = init_magic_struct(pt, sq, &mut offset);

        populate_table(pt, sq, &m, &mut reference, &mut occupancy);

        total_attempt += find_magics::<N>(
            seeds[sq.rank() as usize],
            &mut m,
            &mut reference,
            &mut occupancy,
            &mut table,
        );

        // Store the magic number for the square
        magic[sq as usize] = m;

        if sq.file() == File::FileH {
            println!("{}", total_attempt);
            total_attempt = 0;
        }
    }

    SliderAttackTable { table, magic }
}

/// # Find Best Magic Seeds
pub fn find_best_magic_seeds<const N: usize>(pt: PieceType) {
    let mut offset = 0;
    let mut magic = [Magic::default(); Square::NUM];

    for sq in Square::iter() {
        // Initialize the magic struct for the piece type on the square
        magic[sq as usize] = init_magic_struct(pt, sq, &mut offset);
    }

    let mut reference = [[Bitboard::EMPTY; MAX_PERM]; File::NUM];
    let mut occupancy = [[Bitboard::EMPTY; MAX_PERM]; File::NUM];
    let mut table = Box::new([Bitboard::EMPTY; N]);

    // Loop through the squares and generate the magic numbers for the piece type
    for rank in Rank::iter() {
        let mut seeder = PRNG::default();

        let mut best_attempt = 0;
        let mut best_seed = 0;
        for file in File::iter() {
            let sq = (file, rank).into();
            let m = &magic[sq as usize];

            let perm = 1 << m.mask.count_bits();
            // Populate the reference and occupancy tables for the piece type on the square
            let mut occ = Bitboard::EMPTY;
            for i in 0..perm {
                // Generate the corresponding attack rays for the occupancy, piece type, and square
                reference[file as usize][i] = attacks_on_the_fly(pt, sq, occ);
                // Store the occupancy bitboard at the current index
                occupancy[file as usize][i] = occ;
                // Save occupancy bitboard at the current index
                occ = (occ - m.mask) & m.mask;
            }
        }

        for i in 0..10000 {
            let mut total_attempt = 0;
            let seed = seeder.random_u64();

            for file in File::iter() {
                let sq: Square = (file, rank).into();
                let m = &mut magic[sq as usize];

                let mut trying = true;
                let mut attempt = 0;
                let mut rng = PRNG::new(seed);
                let mut epoch = [0u32; MAX_PERM];
                let perm = 1 << m.mask.count_bits();
                // Find a magic for a specific mask/square until we find one that passes the
                // verification test
                while trying {
                    m.magic = 0;

                    // Aim to find a magic number that is sparsely populated
                    while ((m.magic.wrapping_mul(m.mask.0)) >> 56).count_ones() < 6 {
                        m.magic = rng.random_sparse_u64();
                        // New magic number
                        attempt += 1;
                        // Assume the new magic number is valid, until proven otherwise
                        trying = false;
                        // A valid magic must map every possible occupancy to an index that
                        // looks up the correct sliding atttack in the attacks lookup table.

                        for i in 0..perm {
                            let idx = m.index(occupancy[file as usize][i]);
                            // Trick to speed up the search for magic numbers
                            // The m.attacks table will be slowly replaced with the attacks
                            // generated by the new magic number Avoid resetting m.attacks every
                            // time
                            if epoch[idx - m.offset] < attempt {
                                // Update the count
                                epoch[idx - m.offset] = attempt;
                                // Update the table with the attack pattern
                                table[idx] = reference[file as usize][i];
                            // If the index is already occupied, check if the attack pattern stored is the same as the one we are trying to insert
                            } else if table[idx] != reference[file as usize][i] {
                                // Keep trying new magic numbers until we find one that works
                                trying = true;
                                break;
                            }
                        }
                    }
                }

                total_attempt += attempt;

                if total_attempt > best_attempt && best_attempt != 0 {
                    break;
                }
            }

            if best_attempt > total_attempt || best_attempt == 0 {
                best_attempt = total_attempt;
                best_seed = seed;
            }

            if i % 100 == 0 {
                println!(
                    "Rank: {rank:?}, Iteration: {i}, Best: ({}, {:#X})",
                    best_attempt, best_seed
                );
            }
        }

        println!("============================================================");
        println!("Best Attempt: {best_attempt}, Best Seed: {best_seed:#X}");
        println!("============================================================");
    }
}
